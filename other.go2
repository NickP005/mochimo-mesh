package main

import (
	"encoding/binary"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"

	"github.com/NickP005/go_mcminterface"
)

type NetworkIdentifier struct {
	Blockchain string `json:"blockchain"`
	Network    string `json:"network"`
}

type BlockIdentifier struct {
	Index uint64 `json:"index,omitempty"`
	Hash  string `json:"hash,omitempty"`
}

type BlockRequest struct {
	NetworkIdentifier NetworkIdentifier `json:"network_identifier"`
	BlockIdentifier   BlockIdentifier   `json:"block_identifier"`
}

type TransactionIdentifier struct {
	Hash string `json:"hash"`
}

type Operation struct {
	OperationIdentifier struct {
		Index int `json:"index"`
	} `json:"operation_identifier"`
	Type    string `json:"type"`
	Status  string `json:"status"`
	Account struct {
		Address string `json:"address"`
	} `json:"account"`
	Amount struct {
		Value    string `json:"value"`
		Currency struct {
			Symbol   string `json:"symbol"`
			Decimals int    `json:"decimals"`
		} `json:"currency"`
	} `json:"amount"`
}

type Transaction struct {
	TransactionIdentifier TransactionIdentifier `json:"transaction_identifier"`
	Operations            []Operation           `json:"operations"`
}

type Block struct {
	BlockIdentifier       BlockIdentifier `json:"block_identifier"`
	ParentBlockIdentifier BlockIdentifier `json:"parent_block_identifier"`
	Timestamp             int64           `json:"timestamp"`
	Transactions          []Transaction   `json:"transactions"`
}

type BlockResponse struct {
	Block Block  `json:"block"`
	Error string `json:"error,omitempty"`
}

func main() {
	go_mcminterface.LoadSettings("settings.json")

	http.HandleFunc("/block", blockHandler)
	log.Println("Server started at :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

func blockHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	var req BlockRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	block, err := getBlock(req.BlockIdentifier)
	if err != nil {
		response := BlockResponse{
			Error: err.Error(),
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	response := BlockResponse{
		Block: block,
	}
	json.NewEncoder(w).Encode(response)
}

func getBlock(blockIdentifier BlockIdentifier) (Block, error) {
	var blockData go_mcminterface.Block
	var err error
	if blockIdentifier.Index != 0 {
		blockData, err = go_mcminterface.QueryBlockFromNumber(uint64(blockIdentifier.Index))
		if err != nil {
			return Block{}, err
		}
	} else if blockIdentifier.Hash != "" {
		// Convert hash to bytes and query
	} else {
		return Block{}, fmt.Errorf("block identifier not provided")
	}

	block := Block{
		BlockIdentifier: BlockIdentifier{
			Index: binary.LittleEndian.Uint64(blockData.Trailer.Bnum[:]),
			Hash:  fmt.Sprintf("%x", blockData.Trailer.Bhash[:]),
		},
		ParentBlockIdentifier: BlockIdentifier{
			Index: binary.LittleEndian.Uint64(blockData.Trailer.Bnum[:]) - 1, // Placeholder
			Hash:  fmt.Sprintf("%x", blockData.Trailer.Phash[:]),
		},
		Timestamp:    int64(binary.LittleEndian.Uint32(blockData.Trailer.Time0[:])),
		Transactions: []Transaction{},
	}

	for _, tx := range blockData.Body {
		transaction := Transaction{
			TransactionIdentifier: TransactionIdentifier{
				Hash: fmt.Sprintf("%x", tx.Tx_id[:]),
			},
			Operations: []Operation{},
		}

		operations := []Operation{
			{
				OperationIdentifier: struct {
					Index int `json:"index"`
				}{
					Index: 0,
				},
				Type:   "TRANSFER",
				Status: "SUCCESS",
				Account: struct {
					Address string `json:"address"`
				}{
					Address: fmt.Sprintf("%x", tx.Src_addr[:]), // Full WOTS+ address or tag
				},
				Amount: struct {
					Value    string `json:"value"`
					Currency struct {
						Symbol   string `json:"symbol"`
						Decimals int    `json:"decimals"`
					} `json:"currency"`
				}{
					Value: strconv.FormatUint(binary.LittleEndian.Uint64(tx.Send_total[:]), 10),
					Currency: struct {
						Symbol   string `json:"symbol"`
						Decimals int    `json:"decimals"`
					}{
						Symbol:   "MCM",
						Decimals: 8,
					},
				},
			},
			{
				OperationIdentifier: struct {
					Index int `json:"index"`
				}{
					Index: 1,
				},
				Type:   "TRANSFER",
				Status: "SUCCESS",
				Account: struct {
					Address string `json:"address"`
				}{
					Address: fmt.Sprintf("%x", tx.Dst_addr[:]), // Full WOTS+ address or tag
				},
				Amount: struct {
					Value    string `json:"value"`
					Currency struct {
						Symbol   string `json:"symbol"`
						Decimals int    `json:"decimals"`
					} `json:"currency"`
				}{
					Value: fmt.Sprintf("-%d", int64(binary.LittleEndian.Uint64(tx.Send_total[:]))),
					Currency: struct {
						Symbol   string `json:"symbol"`
						Decimals int    `json:"decimals"`
					}{
						Symbol:   "MCM",
						Decimals: 8,
					},
				},
			},
		}

		transaction.Operations = append(transaction.Operations, operations...)
		block.Transactions = append(block.Transactions, transaction)
	}

	return block, nil
}
